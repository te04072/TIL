## 메모이제이션과 DP의 관계

### 1. 메모이제이션 (Memoization)

- 정의: 이전에 계산한 결과를 저장하고 재사용하는 최적화 기법
- 특징:
  - 주로 재귀 함수에서 사용됨
  - Top-down 방식으로 구현 (큰 문제에서 작은 문제로)
  - 필요한 부분만 계산 (Lazy Evaluation)
- 장점: 
  - 구현이 직관적이고 간단함
  - 필요한 부분만 계산하므로 불필요한 계산 회피 가능
- 단점:
  - 재귀 호출로 인한 오버헤드 발생 가능
  - 스택 오버플로우 위험

### 2. 동적 계획법 (Dynamic Programming, DP)

- 정의: 복잡한 문제를 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법
- 특징:
  - 반복문을 사용하여 구현하는 경우가 많음
  - Bottom-up 방식으로 구현 (작은 문제에서 큰 문제로)
  - 모든 부분 문제를 한 번씩 계산
- 장점
  - 반복문 사용으로 재귀 호출 오버헤드 없음
  - 모든 부분 문제를 순차적으로 해결하여 안정적
- 단점
  - 때로는 불필요한 부분까지 계산할 수 있음
  - 구현이 메모이제이션보다 복잡할 수 있음

### 3. 관계

- 메모이제이션은 DP를 구현하는 한 가지 방법
- DP는 메모이제이션을 포함하는 더 넓은 개념
- 둘 다 중복 계산을 피하고 효율성을 높이는 것이 목표



### 4. 예시: 피보나치 수열

메모이제이션 (Top-down):

```python
def fib(n, memo={}):
    # 이미 계산된 값이 있으면 그 값을 반환
    if n in memo:
        return memo[n]
    
    # 기본 케이스: f(0) = 0, f(1) = 1
    if n <= 1:
        return n
    
    # 재귀적으로 f(n-1)과 f(n-2)를 계산하고 그 합을 저장
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    
    # 계산된 값 반환
    return memo[n]

# 사용 예:
# result = fib(10)
# print(result)  # 55 출력
```

> - 재귀 호출을 사용합니다.
> - `memo` 딕셔너리를 사용하여 이전에 계산한 값을 저장합니다.
> - 필요한 값만 계산하므로 불필요한 계산을 피할 수 있습니다.
> - Top-down 방식: 큰 문제(n)에서 시작하여 작은 문제로 내려갑니다.



DP (Bottom-up):

```python
def fib(n):
    # 기본 케이스 처리
    if n <= 1:
        return n
    
    # DP 테이블 초기화 (0부터 n까지의 인덱스를 가짐)
    dp = [0] * (n+1)
    
    # 기본 값 설정
    dp[1] = 1
    
    # 작은 값부터 큰 값으로 순차적으로 계산
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    
    # n번째 피보나치 수 반환
    return dp[n]

# 사용 예:
# result = fib(10)
# print(result)  # 55 출력
```

> - 반복문을 사용하여 구현합니다.
> - `dp` 리스트를 사용하여 모든 중간 결과를 저장합니다.
> - 0부터 n까지 순차적으로 모든 값을 계산합니다.
> - Bottom-up 방식: 작은 문제(0, 1)에서 시작하여 큰 문제(n)로 올라갑니다.



두 방법 모두 중복 계산을 피하고 효율성을 높이는 데 사용되지만, 접근 방식과 구현 방법에서 차이가 있습니다.

