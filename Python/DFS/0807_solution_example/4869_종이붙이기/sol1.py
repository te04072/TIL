import sys

sys.stdin = open('input.txt')

# 메모이제이션을 위한 리스트 초기화
# 20xN 크기의 테이블을 덮는 방법의 수를 저장하는 리스트
memo = [0, 1, 3]

# 20xN 크기의 테이블을 덮는 방법의 수를 미리 계산하여 메모이제이션
for i in range(2, 30):
    # memo[i]는 20x(i*10) 크기의 테이블을 덮는 방법의 수
    # 이 점화식은 이전 값 memo[i]와 memo[i - 1]을 이용해 현재 값을 계산
    # 이전 테이블 덮는 방법을 두 배로 확장하는 방식
    memo.append(memo[i] + memo[i - 1] * 2)

# 테스트 케이스 개수 입력
T = int(input())

# 각 테스트 케이스 처리
for tc in range(1, T + 1):
    N = int(input())
    # 결과 출력
    result = memo[N // 10]
    print(f'#{tc} {result}')


"""
**해당 코드가 작성된 원리**

기본 케이스:
    20xN 크기의 테이블을 덮는 방법을 f(n)이라고 합시다.
    f(10): 10x20 크기의 종이 1개로 덮을 수 있습니다. 따라서 경우의 수는 1입니다.
    f(20): 20x20 크기의 종이 1개 또는 10x20 크기의 종이 2개로 덮을 수 있습니다. 따라서 경우의 수는 3입니다.

이제, 20xN 크기의 테이블을 덮는 방법을 두 가지로 나눌 수 있습니다:
  1. 10x20 크기의 종이로 20x(N-10) 크기의 테이블을 덮는 경우
  2. 20x20 크기의 종이로 20x(N-20) 크기의 테이블을 덮는 경우와 10x20 크기의 종이 두 개로 20x(N-20) 크기의 테이블을 덮는 경우

따라서 점화식은 다음과 같습니다
    f(n) = f(n-10) + 2*f(n-20)

이제 이 점화식을 코드로 구현해 보겠습니다. 
메모이제이션을 사용하여 중복 계산을 피하고 효율적으로 값을 구할 것입니다. 
메모이제이션을 위한 리스트 memo를 초기화하고, 미리 계산된 값을 저장해 두겠습니다.

for i in range(2, 30):에서 30까지 반복하는 이유
    1. 문제의 제한 조건:
    - 문제에서 주어진 N의 최대값이 300입니다. N은 10의 배수이므로, 가능한 최대 N은 300입니다.
    2. 인덱스 계산:
    - 코드에서는 memo[N//10]을 사용하여 결과를 찾습니다. 여기서 N의 최대값 300을 10으로 나누면 30이 됩니다.
    3. 메모이제이션 배열 크기:
    - 따라서 memo 배열의 크기는 최소한 31(0부터 30까지)이어야 모든 가능한 N에 대한 결과를 저장할 수 있습니다.
    4. 초기값 설정:
    - 코드에서 memo = [0, 1, 3]으로 초기화했으므로, 인덱스 0, 1은 이미 설정되어 있습니다.
    5. 반복 범위:
    - 따라서 range(2, 30)을 사용하여 인덱스 2부터 29까지 계산하면, 총 31개의 값(0부터 30까지)을 memo 배열에 저장하게 됩니다.

"""
